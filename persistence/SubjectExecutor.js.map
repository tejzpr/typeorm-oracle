{"version":3,"sources":["../../src/persistence/SubjectExecutor.ts"],"names":[],"mappings":"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","file":"SubjectExecutor.js","sourcesContent":["import {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {Subject} from \"./Subject\";\r\nimport {PromiseUtils} from \"../util/PromiseUtils\";\r\nimport {SubjectTopoligicalSorter} from \"./SubjectTopoligicalSorter\";\r\nimport {SubjectChangedColumnsComputer} from \"./SubjectChangedColumnsComputer\";\r\nimport {SubjectWithoutIdentifierError} from \"../error/SubjectWithoutIdentifierError\";\r\nimport {SubjectRemovedAndUpdatedError} from \"../error/SubjectRemovedAndUpdatedError\";\r\nimport {MongoQueryRunner} from \"../driver/mongodb/MongoQueryRunner\";\r\nimport {MongoEntityManager} from \"../entity-manager/MongoEntityManager\";\r\nimport {MongoDriver} from \"../driver/mongodb/MongoDriver\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {SaveOptions} from \"../repository/SaveOptions\";\r\nimport {RemoveOptions} from \"../repository/RemoveOptions\";\r\nimport {BroadcasterResult} from \"../subscriber/BroadcasterResult\";\r\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\r\nimport {NestedSetSubjectExecutor} from \"./tree/NestedSetSubjectExecutor\";\r\nimport {ClosureSubjectExecutor} from \"./tree/ClosureSubjectExecutor\";\r\nimport {MaterializedPathSubjectExecutor} from \"./tree/MaterializedPathSubjectExecutor\";\r\n\r\n/**\r\n * Executes all database operations (inserts, updated, deletes) that must be executed\r\n * with given persistence subjects.\r\n */\r\nexport class SubjectExecutor {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\r\n     */\r\n    hasExecutableOperations: boolean = false;\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * QueryRunner used to execute all queries with a given subjects.\r\n     */\r\n    protected queryRunner: QueryRunner;\r\n\r\n    /**\r\n     * Persistence options.\r\n     */\r\n    protected options?: SaveOptions & RemoveOptions;\r\n\r\n    /**\r\n     * All subjects that needs to be operated.\r\n     */\r\n    protected allSubjects: Subject[];\r\n\r\n    /**\r\n     * Subjects that must be inserted.\r\n     */\r\n    protected insertSubjects: Subject[] = [];\r\n\r\n    /**\r\n     * Subjects that must be updated.\r\n     */\r\n    protected updateSubjects: Subject[] = [];\r\n\r\n    /**\r\n     * Subjects that must be removed.\r\n     */\r\n    protected removeSubjects: Subject[] = [];\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(queryRunner: QueryRunner, subjects: Subject[], options?: SaveOptions & RemoveOptions) {\r\n        this.queryRunner = queryRunner;\r\n        this.allSubjects = subjects;\r\n        this.options = options;\r\n        this.validate();\r\n        this.recompute();\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Executes all operations over given array of subjects.\r\n     * Executes queries using given query runner.\r\n     */\r\n    async execute(): Promise<void> {\r\n        // console.time(\"SubjectExecutor.execute\");\r\n\r\n        // broadcast \"before\" events before we start insert / update / remove operations\r\n        let broadcasterResult: BroadcasterResult|undefined = undefined;\r\n        if (!this.options || this.options.listeners !== false) {\r\n            // console.time(\".broadcastBeforeEventsForAll\");\r\n            broadcasterResult = this.broadcastBeforeEventsForAll();\r\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\r\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\r\n        }\r\n\r\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\r\n        // recompute only in the case if any listener or subscriber was really executed\r\n        if (broadcasterResult && broadcasterResult.count > 0) {\r\n            // console.time(\".recompute\");\r\n            this.recompute();\r\n            // console.timeEnd(\".recompute\");\r\n        }\r\n\r\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\r\n\r\n        // console.timeEnd(\"prepare\");\r\n\r\n        // execute all insert operations\r\n        // console.time(\".insertion\");\r\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\r\n        await this.executeInsertOperations();\r\n        // console.timeEnd(\".insertion\");\r\n\r\n        // recompute update operations since insertion can create updation operations for the\r\n        // properties it wasn't able to handle on its own (referenced columns)\r\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\r\n\r\n        // execute update operations\r\n        // console.time(\".updation\");\r\n        await this.executeUpdateOperations();\r\n        // console.timeEnd(\".updation\");\r\n\r\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\r\n        // console.time(\".removal\");\r\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\r\n        await this.executeRemoveOperations();\r\n        // console.timeEnd(\".removal\");\r\n\r\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\r\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\r\n        await this.updateSpecialColumnsInPersistedEntities();\r\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\r\n\r\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\r\n        if (!this.options || this.options.listeners !== false) {\r\n            // console.time(\".broadcastAfterEventsForAll\");\r\n            broadcasterResult = this.broadcastAfterEventsForAll();\r\n            if (broadcasterResult.promises.length > 0) await Promise.all(broadcasterResult.promises);\r\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\r\n        }\r\n        // console.timeEnd(\"SubjectExecutor.execute\");\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Validates all given subjects.\r\n     */\r\n    protected validate() {\r\n        this.allSubjects.forEach(subject => {\r\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\r\n                throw new SubjectRemovedAndUpdatedError(subject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\r\n     */\r\n    protected recompute(): void {\r\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\r\n        this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\r\n        this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\r\n        this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\r\n        this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0;\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\" events for all given subjects.\r\n     */\r\n    protected broadcastBeforeEventsForAll(): BroadcasterResult {\r\n        const result = new BroadcasterResult();\r\n        if (this.insertSubjects.length)\r\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity!));\r\n        if (this.updateSubjects.length)\r\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\r\n        if (this.removeSubjects.length)\r\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\" events for all given subjects.\r\n     * Returns void if there wasn't any listener or subscriber executed.\r\n     * Note: this method has a performance-optimized code organization.\r\n     */\r\n    protected broadcastAfterEventsForAll(): BroadcasterResult {\r\n        const result = new BroadcasterResult();\r\n        if (this.insertSubjects.length)\r\n            this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity!));\r\n        if (this.updateSubjects.length)\r\n            this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\r\n        if (this.removeSubjects.length)\r\n            this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity!, subject.databaseEntity));\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Executes insert operations.\r\n     */\r\n    protected async executeInsertOperations(): Promise<void> {\r\n\r\n        // group insertion subjects to make bulk insertions\r\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\r\n\r\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\r\n        await PromiseUtils.runInSequence(groupedInsertSubjectKeys, async groupName => {\r\n            const subjects = groupedInsertSubjects[groupName];\r\n\r\n            // we must separately insert entities which does not have any values to insert\r\n            // because its not possible to insert multiple entities with only default values in bulk\r\n            const bulkInsertMaps: ObjectLiteral[] = [];\r\n            const bulkInsertSubjects: Subject[] = [];\r\n            const singleInsertSubjects: Subject[] = [];\r\n            if (this.queryRunner.connection.driver instanceof MongoDriver) {\r\n                subjects.forEach(subject => {\r\n                    bulkInsertSubjects.push(subject);\r\n                    bulkInsertMaps.push(subject.entity!);\r\n                });\r\n            } else if (this.queryRunner.connection.driver instanceof OracleDriver) {\r\n                subjects.forEach(subject => {\r\n                    singleInsertSubjects.push(subject);\r\n                });\r\n            } else {\r\n                subjects.forEach(subject => {\r\n\r\n                    // we do not insert in bulk in following cases:\r\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\r\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\r\n                    // - when oracle is used, since oracle's bulk insertion is very bad\r\n                    if (subject.changeMaps.length === 0 ||\r\n                        subject.metadata.treeType ||\r\n                        this.queryRunner.connection.driver instanceof OracleDriver) {\r\n                        singleInsertSubjects.push(subject);\r\n\r\n                    } else {\r\n                        bulkInsertSubjects.push(subject);\r\n                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\r\n                    }\r\n                });\r\n            }\r\n\r\n            // for mongodb we have a bit different insertion logic\r\n            if (this.queryRunner instanceof MongoQueryRunner) {\r\n\r\n                const manager = this.queryRunner.manager as MongoEntityManager;\r\n                const insertResult = await manager.insert(subjects[0].metadata.target, bulkInsertMaps);\r\n                subjects.forEach((subject, index) => {\r\n                    subject.identifier = insertResult.identifiers[index];\r\n                    subject.generatedMap = insertResult.generatedMaps[index];\r\n                    subject.insertedValueSet = bulkInsertMaps[index];\r\n                });\r\n\r\n            } else {\r\n\r\n                // here we execute our insertion query\r\n                // we need to enable entity updation because we DO need to have updated insertedMap\r\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\r\n                // also, we disable listeners because we call them on our own in persistence layer\r\n                if (bulkInsertMaps.length > 0) {\r\n                    const insertResult = await this.queryRunner\r\n                        .manager\r\n                        .createQueryBuilder()\r\n                        .insert()\r\n                        .into(subjects[0].metadata.target)\r\n                        .values(bulkInsertMaps)\r\n                        .updateEntity(this.options && this.options.reload === false ? false : true)\r\n                        .callListeners(false)\r\n                        .execute();\r\n\r\n                    bulkInsertSubjects.forEach((subject, index) => {\r\n                        subject.identifier = insertResult.identifiers[index];\r\n                        subject.generatedMap = insertResult.generatedMaps[index];\r\n                        subject.insertedValueSet = bulkInsertMaps[index];\r\n                    });\r\n                }\r\n\r\n                // insert subjects which must be inserted in separate requests (all default values)\r\n                if (singleInsertSubjects.length > 0) {\r\n                    await PromiseUtils.runInSequence(singleInsertSubjects, async subject => {\r\n                        subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\r\n\r\n                        // for nested set we execute additional queries\r\n                        if (subject.metadata.treeType === \"nested-set\")\r\n                            await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\r\n\r\n                        await this.queryRunner\r\n                            .manager\r\n                            .createQueryBuilder()\r\n                            .insert()\r\n                            .into(subject.metadata.target)\r\n                            .values(subject.insertedValueSet)\r\n                            .updateEntity(this.options && this.options.reload === false ? false : true)\r\n                            .callListeners(false)\r\n                            .execute()\r\n                            .then(insertResult => {\r\n                                subject.identifier = insertResult.identifiers[0];\r\n                                subject.generatedMap = insertResult.generatedMaps[0];\r\n                            });\r\n\r\n                        // for tree tables we execute additional queries\r\n                        if (subject.metadata.treeType === \"closure-table\") {\r\n                            await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\r\n\r\n                        } else if (subject.metadata.treeType === \"materialized-path\") {\r\n                            await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\r\n                        }\r\n                    });\r\n                }\r\n            }\r\n\r\n            subjects.forEach(subject => {\r\n                if (subject.generatedMap) {\r\n                    subject.metadata.columns.forEach(column => {\r\n                        const value = column.getEntityValue(subject.generatedMap!);\r\n                        if (value !== undefined && value !== null) {\r\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\r\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates all given subjects in the database.\r\n     */\r\n    protected async executeUpdateOperations(): Promise<void> {\r\n        await Promise.all(this.updateSubjects.map(async subject => {\r\n\r\n            if (!subject.identifier)\r\n                throw new SubjectWithoutIdentifierError(subject);\r\n\r\n            const updateMap: ObjectLiteral = this.queryRunner.connection.driver instanceof MongoDriver ? subject.entity! : subject.createValueSetAndPopChangeMap();\r\n\r\n            // for mongodb we have a bit different updation logic\r\n            if (this.queryRunner instanceof MongoQueryRunner) {\r\n                const manager = this.queryRunner.manager as MongoEntityManager;\r\n                await manager.update(subject.metadata.target, subject.identifier, updateMap);\r\n\r\n            } else {\r\n\r\n                // here we execute our updation query\r\n                // we need to enable entity updation because we update a subject identifier\r\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\r\n                // also, we disable listeners because we call them on our own in persistence layer\r\n                const updateQueryBuilder = this.queryRunner\r\n                    .manager\r\n                    .createQueryBuilder()\r\n                    .update(subject.metadata.target)\r\n                    .set(updateMap)\r\n                    .updateEntity(this.options && this.options.reload === false ? false : true)\r\n                    .callListeners(false);\r\n\r\n                if (subject.entity) {\r\n                    updateQueryBuilder.whereEntity(subject.identifier);\r\n\r\n                } else { // in this case identifier is just conditions object to update by\r\n                    updateQueryBuilder.where(subject.identifier);\r\n                }\r\n\r\n                const updateResult = await updateQueryBuilder.execute();\r\n                subject.generatedMap = updateResult.generatedMaps[0];\r\n                if (subject.generatedMap) {\r\n                    subject.metadata.columns.forEach(column => {\r\n                        const value = column.getEntityValue(subject.generatedMap!);\r\n                        if (value !== undefined && value !== null) {\r\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\r\n                            column.setEntityValue(subject.generatedMap!, preparedValue);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // experiments, remove probably, need to implement tree tables children removal\r\n                // if (subject.updatedRelationMaps.length > 0) {\r\n                //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\r\n                //         if (!updatedRelation.relation.isTreeParent) return;\r\n                //         if (!updatedRelation.value !== null) return;\r\n                //\r\n                //         if (subject.metadata.treeType === \"closure-table\") {\r\n                //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\r\n                //         }\r\n                //     }));\r\n                // }\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Removes all given subjects from the database.\r\n     *\r\n     * todo: we need to apply topological sort here as well\r\n     */\r\n    protected async executeRemoveOperations(): Promise<void> {\r\n        // group insertion subjects to make bulk insertions\r\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\r\n\r\n        await PromiseUtils.runInSequence(groupedRemoveSubjectKeys, async groupName => {\r\n            const subjects = groupedRemoveSubjects[groupName];\r\n            const deleteMaps = subjects.map(subject => {\r\n                if (!subject.identifier)\r\n                    throw new SubjectWithoutIdentifierError(subject);\r\n\r\n                return subject.identifier;\r\n            });\r\n\r\n            // for mongodb we have a bit different updation logic\r\n            if (this.queryRunner instanceof MongoQueryRunner) {\r\n                const manager = this.queryRunner.manager as MongoEntityManager;\r\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\r\n\r\n            } else {\r\n\r\n                // here we execute our deletion query\r\n                // we don't need to specify entities and set update entity to true since the only thing query builder\r\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\r\n                // also, we disable listeners because we call them on our own in persistence layer\r\n                await this.queryRunner\r\n                    .manager\r\n                    .createQueryBuilder()\r\n                    .delete()\r\n                    .from(subjects[0].metadata.target)\r\n                    .where(deleteMaps)\r\n                    .callListeners(false)\r\n                    .execute();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\r\n     * Also updates nullable columns and columns with default values.\r\n     */\r\n    protected updateSpecialColumnsInPersistedEntities(): void {\r\n\r\n        // update inserted entity properties\r\n        if (this.insertSubjects.length)\r\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\r\n\r\n        // update updated entity properties\r\n        if (this.updateSubjects.length)\r\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\r\n\r\n        // remove ids from the entities that were removed\r\n        if (this.removeSubjects.length) {\r\n            this.removeSubjects.forEach(subject => {\r\n                if (!subject.entity) return;\r\n\r\n                subject.metadata.primaryColumns.forEach(primaryColumn => {\r\n                    primaryColumn.setEntityValue(subject.entity!, undefined);\r\n                });\r\n            });\r\n        }\r\n\r\n        // other post-persist updations\r\n        this.allSubjects.forEach(subject => {\r\n            if (!subject.entity) return;\r\n\r\n            subject.metadata.relationIds.forEach(relationId => {\r\n                relationId.setValue(subject.entity!);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\r\n     * Also updates nullable columns and columns with default values.\r\n     */\r\n    protected updateSpecialColumnsInInsertedAndUpdatedEntities(subjects: Subject[]): void {\r\n        subjects.forEach(subject => {\r\n            if (!subject.entity) return;\r\n\r\n            // set values to \"null\" for nullable columns that did not have values\r\n            subject.metadata.columns.forEach(column => {\r\n\r\n                // if table inheritance is used make sure this column is not child's column\r\n                if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1)\r\n                    return;\r\n\r\n                // entities does not have virtual columns\r\n                if (column.isVirtual)\r\n                    return;\r\n\r\n                // update nullable columns\r\n                if (column.isNullable) {\r\n                    const columnValue = column.getEntityValue(subject.entity!);\r\n                    if (columnValue === undefined)\r\n                        column.setEntityValue(subject.entity!, null);\r\n                }\r\n\r\n                // update relational columns\r\n                if (subject.updatedRelationMaps.length > 0) {\r\n                    subject.updatedRelationMaps.forEach(updatedRelationMap => {\r\n                        updatedRelationMap.relation.joinColumns.forEach(column => {\r\n                            if (column.isVirtual === true)\r\n                                return;\r\n\r\n                            column.setEntityValue(subject.entity!, updatedRelationMap.value instanceof Object ? column.referencedColumn!.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\r\n                        });\r\n                    });\r\n                }\r\n            });\r\n\r\n            // merge into entity all generated values returned by a database\r\n            if (subject.generatedMap)\r\n                this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\r\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\r\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\r\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\r\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\r\n     * That's why we only support bulking in junction tables for those drivers.\r\n     *\r\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\r\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\r\n     */\r\n    protected groupBulkSubjects(subjects: Subject[], type: \"insert\"|\"delete\"): [{ [key: string]: Subject[] }, string[]] {\r\n        const group: { [key: string]: Subject[] } = {};\r\n        const keys: string[] = [];\r\n        const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported();\r\n\r\n        subjects.forEach((subject, index) => {\r\n            const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\r\n            if (!group[key]) {\r\n                group[key] = [subject];\r\n                keys.push(key);\r\n            } else {\r\n                group[key].push(subject);\r\n            }\r\n        });\r\n\r\n        return [group, keys];\r\n    }\r\n\r\n}\r\n"],"sourceRoot":".."}