{"version":3,"sources":["../../src/persistence/subject-builder/CascadesSubjectBuilder.ts"],"names":[],"mappings":";;AAAA,sCAAmC;AAGnC;;;GAGG;AACH;IAEI,wEAAwE;IACxE,cAAc;IACd,wEAAwE;IAExE,gCAAsB,WAAsB;QAAtB,gBAAW,GAAX,WAAW,CAAW;IAC5C,CAAC;IAED,wEAAwE;IACxE,iBAAiB;IACjB,wEAAwE;IAExE;;OAEG;IACH,sCAAK,GAAL,UAAM,OAAgB;QAAtB,iBAyCC;QAvCG,OAAO,CAAC,QAAQ;aACX,+BAA+B,CAAC,OAAO,CAAC,MAAO,EAAE,OAAO,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,sDAAsD;aACnI,OAAO,CAAC,UAAC,EAAkD;gBAAjD,gBAAQ,EAAE,sBAAc,EAAE,8BAAsB;YAEvD,0FAA0F;YAC1F,IAAI,cAAc,KAAK,SAAS;gBAC5B,cAAc,KAAK,IAAI;gBACvB,CAAC,CAAC,QAAQ,CAAC,eAAe,IAAI,CAAC,QAAQ,CAAC,eAAe,CAAC;gBACxD,OAAO;YAEX,0EAA0E;YAC1E,2FAA2F;YAC3F,IAAI,CAAC,CAAC,cAAc,YAAY,MAAM,CAAC;gBACnC,OAAO;YAEX,6FAA6F;YAC7F,IAAM,iCAAiC,GAAG,KAAI,CAAC,uBAAuB,CAAC,sBAAsB,CAAC,MAAM,EAAE,cAAc,CAAC,CAAC;YACtH,IAAI,iCAAiC,EAAE;gBACnC,IAAI,iCAAiC,CAAC,aAAa,KAAK,KAAK,EAAE,sCAAsC;oBACjG,iCAAiC,CAAC,aAAa,GAAG,QAAQ,CAAC,eAAe,KAAK,IAAI,CAAC;gBACxF,IAAI,iCAAiC,CAAC,YAAY,KAAK,KAAK,EAAE,mCAAmC;oBAC7F,iCAAiC,CAAC,YAAY,GAAG,QAAQ,CAAC,eAAe,KAAK,IAAI,CAAC;gBACvF,OAAO;aACV;YAED,2CAA2C;YAC3C,yFAAyF;YACzF,IAAM,qBAAqB,GAAG,IAAI,iBAAO,CAAC;gBACtC,QAAQ,EAAE,sBAAsB;gBAChC,aAAa,EAAE,OAAO;gBACtB,MAAM,EAAE,cAAc;gBACtB,aAAa,EAAE,QAAQ,CAAC,eAAe,KAAK,IAAI;gBAChD,YAAY,EAAE,QAAQ,CAAC,eAAe,KAAK,IAAI;aAClD,CAAC,CAAC;YACH,KAAI,CAAC,WAAW,CAAC,IAAI,CAAC,qBAAqB,CAAC,CAAC;YAE7C,kEAAkE;YAClE,KAAI,CAAC,KAAK,CAAC,qBAAqB,CAAC,CAAC;QACtC,CAAC,CAAC,CAAC;IACX,CAAC;IAED,wEAAwE;IACxE,oBAAoB;IACpB,wEAAwE;IAExE;;;OAGG;IACO,wDAAuB,GAAjC,UAAkC,YAA6B,EAAE,MAAqB;QAClF,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,UAAA,OAAO;YAChC,IAAI,CAAC,OAAO,CAAC,MAAM;gBACf,OAAO,KAAK,CAAC;YAEjB,IAAI,OAAO,CAAC,MAAM,KAAK,MAAM;gBACzB,OAAO,IAAI,CAAC;YAEhB,OAAO,OAAO,CAAC,QAAQ,CAAC,MAAM,KAAK,YAAY,IAAI,OAAO,CAAC,QAAQ,CAAC,eAAe,CAAC,OAAO,CAAC,sBAAuB,EAAE,MAAM,CAAC,CAAC;QACjI,CAAC,CAAC,CAAC;IACP,CAAC;IAEL,6BAAC;AAAD,CA/EA,AA+EC,IAAA;AA/EY,wDAAsB","file":"CascadesSubjectBuilder.js","sourcesContent":["import {Subject} from \"../Subject\";\r\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\r\n\r\n/**\r\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\r\n * e.g. builds a cascade tree and creates a subjects for them.\r\n */\r\nexport class CascadesSubjectBuilder {\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(protected allSubjects: Subject[]) {\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\r\n     */\r\n    build(subject: Subject) {\r\n\r\n        subject.metadata\r\n            .extractRelationValuesFromEntity(subject.entity!, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\r\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\r\n\r\n                // we need only defined values and insert or update cascades of the relation should be set\r\n                if (relationEntity === undefined ||\r\n                    relationEntity === null ||\r\n                    (!relation.isCascadeInsert && !relation.isCascadeUpdate))\r\n                    return;\r\n\r\n                // if relation entity is just a relation id set (for example post.tag = 1)\r\n                // then we don't really need to check cascades since there is no object to insert or update\r\n                if (!(relationEntity instanceof Object))\r\n                    return;\r\n\r\n                // if we already has this entity in list of operated subjects then skip it to avoid recursion\r\n                const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\r\n                if (alreadyExistRelationEntitySubject) {\r\n                    if (alreadyExistRelationEntitySubject.canBeInserted === false) // if its not marked for insertion yet\r\n                        alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true;\r\n                    if (alreadyExistRelationEntitySubject.canBeUpdated === false) // if its not marked for update yet\r\n                        alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true;\r\n                    return;\r\n                }\r\n\r\n                // mark subject with what we can do with it\r\n                // and add to the array of subjects to load only if there is no same entity there already\r\n                const relationEntitySubject = new Subject({\r\n                    metadata: relationEntityMetadata,\r\n                    parentSubject: subject,\r\n                    entity: relationEntity,\r\n                    canBeInserted: relation.isCascadeInsert === true,\r\n                    canBeUpdated: relation.isCascadeUpdate === true\r\n                });\r\n                this.allSubjects.push(relationEntitySubject);\r\n\r\n                // go recursively and find other entities we need to insert/update\r\n                this.build(relationEntitySubject);\r\n            });\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Protected Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    /**\r\n     * Finds subject where entity like given subject's entity.\r\n     * Comparision made by entity id.\r\n     */\r\n    protected findByPersistEntityLike(entityTarget: Function|string, entity: ObjectLiteral): Subject|undefined {\r\n        return this.allSubjects.find(subject => {\r\n            if (!subject.entity)\r\n                return false;\r\n\r\n            if (subject.entity === entity)\r\n                return true;\r\n\r\n            return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds!, entity);\r\n        });\r\n    }\r\n\r\n}"],"sourceRoot":"../.."}