{"version":3,"sources":["../../src/metadata/EntityMetadata.ts"],"names":[],"mappings":"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","file":"EntityMetadata.js","sourcesContent":["import {ColumnMetadata} from \"./ColumnMetadata\";\r\nimport {RelationMetadata} from \"./RelationMetadata\";\r\nimport {IndexMetadata} from \"./IndexMetadata\";\r\nimport {ForeignKeyMetadata} from \"./ForeignKeyMetadata\";\r\nimport {EmbeddedMetadata} from \"./EmbeddedMetadata\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {RelationIdMetadata} from \"./RelationIdMetadata\";\r\nimport {RelationCountMetadata} from \"./RelationCountMetadata\";\r\nimport {TableType} from \"./types/TableTypes\";\r\nimport {OrderByCondition} from \"../find-options/OrderByCondition\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\nimport {TableMetadataArgs} from \"../metadata-args/TableMetadataArgs\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {EntityListenerMetadata} from \"./EntityListenerMetadata\";\r\nimport {PostgresDriver} from \"../driver/postgres/PostgresDriver\";\r\nimport {SqlServerDriver} from \"../driver/sqlserver/SqlServerDriver\";\r\nimport {PostgresConnectionOptions} from \"../driver/postgres/PostgresConnectionOptions\";\r\nimport {SqlServerConnectionOptions} from \"../driver/sqlserver/SqlServerConnectionOptions\";\r\nimport {CannotCreateEntityIdMapError} from \"../error/CannotCreateEntityIdMapError\";\r\nimport {TreeType} from \"./types/TreeTypes\";\r\nimport {TreeMetadataArgs} from \"../metadata-args/TreeMetadataArgs\";\r\nimport {UniqueMetadata} from \"./UniqueMetadata\";\r\nimport {CheckMetadata} from \"./CheckMetadata\";\r\nimport {QueryRunner} from \"..\";\r\n\r\n/**\r\n * Contains all entity metadata.\r\n */\r\nexport class EntityMetadata {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Properties\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Connection where this entity metadata is created.\r\n     */\r\n    connection: Connection;\r\n\r\n    /**\r\n     * Metadata arguments used to build this entity metadata.\r\n     */\r\n    tableMetadataArgs: TableMetadataArgs;\r\n\r\n    /**\r\n     * If entity's table is a closure-typed table, then this entity will have a closure junction table metadata.\r\n     */\r\n    closureJunctionTable: EntityMetadata;\r\n\r\n    /**\r\n     * If this is entity metadata for a junction closure table then its owner closure table metadata will be set here.\r\n     */\r\n    parentClosureEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Parent's entity metadata. Used in inheritance patterns.\r\n     */\r\n    parentEntityMetadata: EntityMetadata;\r\n\r\n    /**\r\n     * Children entity metadatas. Used in inheritance patterns.\r\n     */\r\n    childEntityMetadatas: EntityMetadata[] = [];\r\n\r\n    /**\r\n     * All \"inheritance tree\" from a target entity.\r\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\r\n     * It also contains child entities for single table inheritance.\r\n     */\r\n    inheritanceTree: Function[] = [];\r\n\r\n    /**\r\n     * Table type. Tables can be abstract, closure, junction, embedded, etc.\r\n     */\r\n    tableType: TableType = \"regular\";\r\n\r\n    /**\r\n     * Target class to which this entity metadata is bind.\r\n     * Note, that when using table inheritance patterns target can be different rather then table's target.\r\n     * For virtual tables which lack of real entity (like junction tables) target is equal to their table name.\r\n     */\r\n    target: Function|string;\r\n\r\n    /**\r\n     * Gets the name of the target.\r\n     */\r\n    targetName: string;\r\n\r\n    /**\r\n     * Entity's name.\r\n     * Equal to entity target class's name if target is set to table.\r\n     * If target class is not then then it equals to table name.\r\n     */\r\n    name: string;\r\n\r\n    /**\r\n     * Original user-given table name (taken from schema or @Entity(tableName) decorator).\r\n     * If user haven't specified a table name this property will be undefined.\r\n     */\r\n    givenTableName?: string;\r\n\r\n    /**\r\n     * Entity table name in the database.\r\n     * This is final table name of the entity.\r\n     * This name already passed naming strategy, and generated based on\r\n     * multiple criteria, including user table name and global table prefix.\r\n     */\r\n    tableName: string;\r\n\r\n    /**\r\n     * Entity table path. Contains database name, schema name and table name.\r\n     * E.g. myDB.mySchema.myTable\r\n     */\r\n    tablePath: string;\r\n\r\n    /**\r\n     * Entity schema path. Contains database name and schema name.\r\n     * E.g. myDB.mySchema\r\n     */\r\n    schemaPath?: string;\r\n\r\n    /**\r\n     * Gets the table name without global table prefix.\r\n     * When querying table you need a table name with prefix, but in some scenarios,\r\n     * for example when you want to name a junction table that contains names of two other tables,\r\n     * you may want a table name without prefix.\r\n     */\r\n    tableNameWithoutPrefix: string;\r\n\r\n    /**\r\n     * Indicates if schema will be synchronized for this entity or not.\r\n     */\r\n    synchronize: boolean = true;\r\n\r\n    /**\r\n     * Table's database engine type (like \"InnoDB\", \"MyISAM\", etc).\r\n     */\r\n    engine?: string;\r\n\r\n    /**\r\n     * Database name.\r\n     */\r\n    database?: string;\r\n\r\n    /**\r\n     * Schema name. Used in Postgres and Sql Server.\r\n     */\r\n    schema?: string;\r\n\r\n    /**\r\n     * Specifies a default order by used for queries from this table when no explicit order by is specified.\r\n     */\r\n    orderBy?: OrderByCondition;\r\n\r\n    /**\r\n     * If this entity metadata's table using one of the inheritance patterns,\r\n     * then this will contain what pattern it uses.\r\n     */\r\n    inheritancePattern?: \"STI\"/*|\"CTI\"*/;\r\n\r\n    /**\r\n     * Checks if there any non-nullable column exist in this entity.\r\n     */\r\n    hasNonNullableRelations: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this entity metadata of a junction table, or not.\r\n     * Junction table is a table created by many-to-many relationship.\r\n     *\r\n     * Its also possible to understand if entity is junction via tableType.\r\n     */\r\n    isJunction: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this entity is a tree, what type of tree it is.\r\n     */\r\n    treeType?: TreeType;\r\n\r\n    /**\r\n     * Checks if this table is a junction table of the closure table.\r\n     * This type is for tables that contain junction metadata of the closure tables.\r\n     */\r\n    isClosureJunction: boolean = false;\r\n\r\n    /**\r\n     * Checks if entity's table has multiple primary columns.\r\n     */\r\n    hasMultiplePrimaryKeys: boolean = false;\r\n\r\n    /**\r\n     * Indicates if this entity metadata has uuid generated columns.\r\n     */\r\n    hasUUIDGeneratedColumns: boolean = false;\r\n\r\n    /**\r\n     * If this entity metadata is a child table of some table, it should have a discriminator value.\r\n     * Used to store a value in a discriminator column.\r\n     */\r\n    discriminatorValue?: string;\r\n\r\n    /**\r\n     * Entity's column metadatas defined by user.\r\n     */\r\n    ownColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\r\n     */\r\n    columns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Ancestor columns used only in closure junction tables.\r\n     */\r\n    ancestorColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Descendant columns used only in closure junction tables.\r\n     */\r\n    descendantColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * All columns except for virtual columns.\r\n     */\r\n    nonVirtualColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * In the case if this entity metadata is junction table's entity metadata,\r\n     * this will contain all referenced columns of owner entity.\r\n     */\r\n    ownerColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * In the case if this entity metadata is junction table's entity metadata,\r\n     * this will contain all referenced columns of inverse entity.\r\n     */\r\n    inverseColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Gets the column with generated flag.\r\n     */\r\n    generatedColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Gets the object id column used with mongodb database.\r\n     */\r\n    objectIdColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains a create date value.\r\n     */\r\n    createDateColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains an update date value.\r\n     */\r\n    updateDateColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets entity column which contains an entity version.\r\n     */\r\n    versionColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets the discriminator column used to store entity identificator in single-table inheritance tables.\r\n     */\r\n    discriminatorColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Special column that stores tree level in tree entities.\r\n     */\r\n    treeLevelColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Nested set's left value column.\r\n     * Used only in tree entities with nested set pattern applied.\r\n     */\r\n    nestedSetLeftColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Nested set's right value column.\r\n     * Used only in tree entities with nested set pattern applied.\r\n     */\r\n    nestedSetRightColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Materialized path column.\r\n     * Used only in tree entities with materialized path pattern applied.\r\n     */\r\n    materializedPathColumn?: ColumnMetadata;\r\n\r\n    /**\r\n     * Gets the primary columns.\r\n     */\r\n    primaryColumns: ColumnMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's relation metadatas.\r\n     */\r\n    ownRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\r\n     */\r\n    relations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * List of eager relations this metadata has.\r\n     */\r\n    eagerRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * List of eager relations this metadata has.\r\n     */\r\n    lazyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only one-to-one relations of the entity.\r\n     */\r\n    oneToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner one-to-one relations of the entity.\r\n     */\r\n    ownerOneToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only one-to-many relations of the entity.\r\n     */\r\n    oneToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only many-to-one relations of the entity.\r\n     */\r\n    manyToOneRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only many-to-many relations of the entity.\r\n     */\r\n    manyToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner many-to-many relations of the entity.\r\n     */\r\n    ownerManyToManyRelations: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Gets only owner one-to-one and many-to-one relations.\r\n     */\r\n    relationsWithJoinColumns: RelationMetadata[] = [];\r\n\r\n    /**\r\n     * Tree parent relation. Used only in tree-tables.\r\n     */\r\n    treeParentRelation?: RelationMetadata;\r\n\r\n    /**\r\n     * Tree children relation. Used only in tree-tables.\r\n     */\r\n    treeChildrenRelation?: RelationMetadata;\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationIds: RelationIdMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's relation id metadatas.\r\n     */\r\n    relationCounts: RelationCountMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's foreign key metadatas.\r\n     */\r\n    foreignKeys: ForeignKeyMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's embedded metadatas.\r\n     */\r\n    embeddeds: EmbeddedMetadata[] = [];\r\n\r\n    /**\r\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\r\n     */\r\n    allEmbeddeds: EmbeddedMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's own indices.\r\n     */\r\n    ownIndices: IndexMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's index metadatas.\r\n     */\r\n    indices: IndexMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's unique metadatas.\r\n     */\r\n    uniques: UniqueMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's check metadatas.\r\n     */\r\n    checks: CheckMetadata[] = [];\r\n\r\n    /**\r\n     * Entity's own listener metadatas.\r\n     */\r\n    ownListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Entity listener metadatas.\r\n     */\r\n    listeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER LOAD\" type.\r\n     */\r\n    afterLoadListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER INSERT\" type.\r\n     */\r\n    beforeInsertListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER INSERT\" type.\r\n     */\r\n    afterInsertListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER UPDATE\" type.\r\n     */\r\n    beforeUpdateListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER UPDATE\" type.\r\n     */\r\n    afterUpdateListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER REMOVE\" type.\r\n     */\r\n    beforeRemoveListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Listener metadatas with \"AFTER REMOVE\" type.\r\n     */\r\n    afterRemoveListeners: EntityListenerMetadata[] = [];\r\n\r\n    /**\r\n     * Map of columns and relations of the entity.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    propertiesMap: ObjectLiteral;\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Constructor\r\n    // ---------------------------------------------------------------------\r\n\r\n    constructor(options: {\r\n        connection: Connection,\r\n        inheritanceTree?: Function[],\r\n        inheritancePattern?: \"STI\"/*|\"CTI\"*/,\r\n        tableTree?: TreeMetadataArgs,\r\n        parentClosureEntityMetadata?: EntityMetadata,\r\n        args: TableMetadataArgs\r\n    }) {\r\n        this.connection = options.connection;\r\n        this.inheritanceTree = options.inheritanceTree || [];\r\n        this.inheritancePattern = options.inheritancePattern;\r\n        this.treeType = options.tableTree ? options.tableTree.type : undefined;\r\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata!;\r\n        this.tableMetadataArgs = options.args;\r\n        this.target = this.tableMetadataArgs.target;\r\n        this.tableType = this.tableMetadataArgs.type;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a new entity.\r\n     */\r\n    create(queryRunner?: QueryRunner): any {\r\n        // if target is set to a function (e.g. class) that can be created then create it\r\n        let ret: any;\r\n        if (this.target instanceof Function) {\r\n            ret = new (<any> this.target)();\r\n            this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\r\n            return ret;\r\n        }\r\n\r\n        // otherwise simply return a new empty object\r\n        const newObject = {};\r\n        this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, newObject, queryRunner));\r\n        return newObject;\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity has an id.\r\n     */\r\n    hasId(entity: ObjectLiteral): boolean {\r\n        if (!entity)\r\n            return false;\r\n\r\n        return this.primaryColumns.every(primaryColumn => {\r\n            const value = primaryColumn.getEntityValue(entity);\r\n            return value !== null && value !== undefined && value !== \"\";\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Checks if given entity / object contains ALL primary keys entity must have.\r\n     * Returns true if it contains all of them, false if at least one of them is not defined.\r\n     */\r\n    hasAllPrimaryKeys(entity: ObjectLiteral): boolean {\r\n        return this.primaryColumns.every(primaryColumn => {\r\n            const value = primaryColumn.getEntityValue(entity);\r\n            return value !== null && value !== undefined;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Ensures that given object is an entity id map.\r\n     * If given id is an object then it means its already id map.\r\n     * If given id isn't an object then it means its a value of the id column\r\n     * and it creates a new id map with this value and name of the primary column.\r\n     */\r\n    ensureEntityIdMap(id: any): ObjectLiteral {\r\n        if (id instanceof Object)\r\n            return id;\r\n\r\n        if (this.hasMultiplePrimaryKeys)\r\n            throw new CannotCreateEntityIdMapError(this, id);\r\n\r\n        return this.primaryColumns[0].createValueMap(id);\r\n    }\r\n\r\n    /**\r\n     * Gets primary keys of the entity and returns them in a literal object.\r\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\r\n     * For multiple primary keys it returns multiple keys in object.\r\n     * For primary keys inside embeds it returns complex object literal with keys in them.\r\n     */\r\n    getEntityIdMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\r\n        if (!entity)\r\n            return undefined;\r\n\r\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, { skipNulls: true });\r\n    }\r\n\r\n    /**\r\n     * Creates a \"mixed id map\".\r\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\r\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\r\n     * This is called mixed id map.\r\n     */\r\n    getEntityIdMixedMap(entity: ObjectLiteral|undefined): ObjectLiteral|undefined {\r\n        if (!entity)\r\n            return entity;\r\n\r\n        const idMap = this.getEntityIdMap(entity);\r\n        if (this.hasMultiplePrimaryKeys) {\r\n            return idMap;\r\n\r\n        } else if (idMap) {\r\n            return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\r\n        }\r\n\r\n        return idMap;\r\n    }\r\n\r\n    /**\r\n     * Compares two different entities by their ids.\r\n     * Returns true if they match, false otherwise.\r\n     */\r\n    compareEntities(firstEntity: ObjectLiteral, secondEntity: ObjectLiteral): boolean {\r\n\r\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity);\r\n        if (!firstEntityIdMap) return false;\r\n\r\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity);\r\n        if (!secondEntityIdMap) return false;\r\n\r\n        return EntityMetadata.compareIds(firstEntityIdMap, secondEntityIdMap);\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given property name.\r\n     */\r\n    findColumnWithPropertyName(propertyName: string): ColumnMetadata|undefined {\r\n        return this.columns.find(column => column.propertyName === propertyName);\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given database name.\r\n     */\r\n    findColumnWithDatabaseName(databaseName: string): ColumnMetadata|undefined {\r\n        return this.columns.find(column => column.databaseName === databaseName);\r\n    }\r\n\r\n    /**\r\n     * Finds column with a given property path.\r\n     */\r\n    findColumnWithPropertyPath(propertyPath: string): ColumnMetadata|undefined {\r\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\r\n        if (column)\r\n            return column;\r\n\r\n        // in the case if column with property path was not found, try to find a relation with such property path\r\n        // if we find relation and it has a single join column then its the column user was seeking\r\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\r\n        if (relation && relation.joinColumns.length === 1)\r\n            return relation.joinColumns[0];\r\n\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Finds columns with a given property path.\r\n     * Property path can match a relation, and relations can contain multiple columns.\r\n     */\r\n    findColumnsWithPropertyPath(propertyPath: string): ColumnMetadata[] {\r\n        const column = this.columns.find(column => column.propertyPath === propertyPath);\r\n        if (column)\r\n            return [column];\r\n\r\n        // in the case if column with property path was not found, try to find a relation with such property path\r\n        // if we find relation and it has a single join column then its the column user was seeking\r\n        const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\r\n        if (relation && relation.joinColumns)\r\n            return relation.joinColumns;\r\n\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Finds relation with the given property path.\r\n     */\r\n    findRelationWithPropertyPath(propertyPath: string): RelationMetadata|undefined {\r\n        return this.relations.find(relation => relation.propertyPath === propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Checks if there is an embedded with a given property path.\r\n     */\r\n    hasEmbeddedWithPropertyPath(propertyPath: string): boolean {\r\n        return this.allEmbeddeds.some(embedded => embedded.propertyPath === propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Finds embedded with a given property path.\r\n     */\r\n    findEmbeddedWithPropertyPath(propertyPath: string): EmbeddedMetadata|undefined {\r\n        return this.allEmbeddeds.find(embedded => embedded.propertyPath === propertyPath);\r\n    }\r\n\r\n    /**\r\n     * Iterates through entity and finds and extracts all values from relations in the entity.\r\n     * If relation value is an array its being flattened.\r\n     */\r\n    extractRelationValuesFromEntity(entity: ObjectLiteral, relations: RelationMetadata[]): [RelationMetadata, any, EntityMetadata][] {\r\n        const relationsAndValues: [RelationMetadata, any, EntityMetadata][] = [];\r\n        relations.forEach(relation => {\r\n            const value = relation.getEntityValue(entity);\r\n            if (value instanceof Array) {\r\n                value.forEach(subValue => relationsAndValues.push([relation, subValue, relation.inverseEntityMetadata]));\r\n            } else if (value) {\r\n                relationsAndValues.push([relation, value, relation.inverseEntityMetadata]);\r\n            }\r\n        });\r\n        return relationsAndValues;\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Static Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Creates a property paths for a given entity.\r\n     */\r\n    static createPropertyPath(metadata: EntityMetadata, entity: ObjectLiteral, prefix: string = \"\") {\r\n        const paths: string[] = [];\r\n        Object.keys(entity).forEach(key => {\r\n\r\n            // check for function is needed in the cases when createPropertyPath used on values containg a function as a value\r\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\r\n            const parentPath = prefix ? prefix + \".\" + key : key;\r\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\r\n                const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\r\n                paths.push(...subPaths);\r\n            } else {\r\n                const path = prefix ? prefix + \".\" + key : key;\r\n                paths.push(path);\r\n            }\r\n        });\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * Finds difference between two entity id maps.\r\n     * Returns items that exist in the first array and absent in the second array.\r\n     */\r\n    static difference(firstIdMaps: ObjectLiteral[], secondIdMaps: ObjectLiteral[]): ObjectLiteral[] {\r\n        return firstIdMaps.filter(firstIdMap => {\r\n            return !secondIdMaps.find(secondIdMap => OrmUtils.deepCompare(firstIdMap, secondIdMap));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Compares ids of the two entities.\r\n     * Returns true if they match, false otherwise.\r\n     */\r\n    static compareIds(firstId: ObjectLiteral|undefined, secondId: ObjectLiteral|undefined): boolean {\r\n        if (firstId === undefined || firstId === null || secondId === undefined || secondId === null)\r\n            return false;\r\n\r\n        return OrmUtils.deepCompare(firstId, secondId);\r\n    }\r\n\r\n    /**\r\n     * Creates value map from the given values and columns.\r\n     * Examples of usages are primary columns map and join columns map.\r\n     */\r\n    static getValueMap(entity: ObjectLiteral, columns: ColumnMetadata[], options?: { skipNulls?: boolean }): ObjectLiteral|undefined {\r\n        return columns.reduce((map, column) => {\r\n            const value = column.getEntityValueMap(entity, options);\r\n\r\n            // make sure that none of the values of the columns are not missing\r\n            if (map === undefined || value === null || value === undefined)\r\n                return undefined;\r\n\r\n            return column.isObjectId ? Object.assign(map, value) : OrmUtils.mergeDeep(map, value);\r\n        }, {} as ObjectLiteral|undefined);\r\n    }\r\n\r\n    // ---------------------------------------------------------------------\r\n    // Public Builder Methods\r\n    // ---------------------------------------------------------------------\r\n\r\n    build() {\r\n        const namingStrategy = this.connection.namingStrategy;\r\n        const entityPrefix = this.connection.options.entityPrefix;\r\n        this.engine = this.tableMetadataArgs.engine;\r\n        this.database = this.tableMetadataArgs.database;\r\n        this.schema = this.tableMetadataArgs.schema || (this.connection.options as PostgresConnectionOptions|SqlServerConnectionOptions).schema;\r\n        this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\r\n        this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\r\n        this.targetName = this.tableMetadataArgs.target instanceof Function ? (this.tableMetadataArgs.target as any).name : this.tableMetadataArgs.target;\r\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\r\n            this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName!);\r\n        } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\r\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\r\n        } else {\r\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\r\n        }\r\n        this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\r\n        this.target = this.target ? this.target : this.tableName;\r\n        this.name = this.targetName ? this.targetName : this.tableName;\r\n        this.tablePath = this.buildTablePath();\r\n        this.schemaPath = this.buildSchemaPath();\r\n        this.orderBy = (this.tableMetadataArgs.orderBy instanceof Function) ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\r\n\r\n        this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\r\n        this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\r\n    }\r\n\r\n    /**\r\n     * Registers a new column in the entity and recomputes all depend properties.\r\n     */\r\n    registerColumn(column: ColumnMetadata) {\r\n        if (this.ownColumns.indexOf(column) !== -1)\r\n            return;\r\n\r\n        this.ownColumns.push(column);\r\n        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\r\n        this.primaryColumns = this.columns.filter(column => column.isPrimary);\r\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\r\n        this.hasUUIDGeneratedColumns = this.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\r\n        this.propertiesMap = this.createPropertiesMap();\r\n        if (this.childEntityMetadatas)\r\n            this.childEntityMetadatas.forEach(entityMetadata => entityMetadata.registerColumn(column));\r\n    }\r\n\r\n    /**\r\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\r\n     * in a special format - { propertyName: propertyName }.\r\n     *\r\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\r\n     * This method will create following object:\r\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\r\n     */\r\n    createPropertiesMap(): { [name: string]: string|any } {\r\n        const map: { [name: string]: string|any } = {};\r\n        this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\r\n        this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * Builds table path using database name, schema name and table name.\r\n     */\r\n    protected buildTablePath(): string {\r\n        let tablePath = this.tableName;\r\n        if (this.schema)\r\n            tablePath = this.schema + \".\" + tablePath;\r\n        if (this.database && !(this.connection.driver instanceof PostgresDriver)) {\r\n            if (!this.schema && this.connection.driver instanceof SqlServerDriver) {\r\n                tablePath = this.database + \"..\" + tablePath;\r\n            } else {\r\n                tablePath = this.database + \".\" + tablePath;\r\n            }\r\n        }\r\n\r\n        return tablePath;\r\n    }\r\n\r\n    /**\r\n     * Builds table path using schema name and database name.\r\n     */\r\n    protected buildSchemaPath(): string|undefined {\r\n        if (!this.schema)\r\n            return undefined;\r\n\r\n        return this.database && !(this.connection.driver instanceof PostgresDriver) ? this.database + \".\" + this.schema : this.schema;\r\n    }\r\n\r\n}"],"sourceRoot":".."}