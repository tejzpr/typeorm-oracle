{"version":3,"sources":["../browser/src/query-builder/transformer/DocumentToEntityTransformer.ts"],"names":[],"mappings":"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","file":"DocumentToEntityTransformer.js","sourcesContent":["import {EntityMetadata} from \"../../metadata/EntityMetadata\";\r\nimport {ObjectLiteral} from \"../../common/ObjectLiteral\";\r\nimport {EmbeddedMetadata} from \"../../metadata/EmbeddedMetadata\";\r\n\r\n/**\r\n * Transforms raw document into entity object.\r\n * Entity is constructed based on its entity metadata.\r\n */\r\nexport class DocumentToEntityTransformer {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(// private selectionMap: AliasMap,\r\n                // private joinMappings: JoinMapping[],\r\n                // private relationCountMetas: RelationCountAttribute[],\r\n                private enableRelationIdValues: boolean = false\r\n    ) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    transformAll(documents: ObjectLiteral[], metadata: EntityMetadata) {\r\n        return documents.map(document => this.transform(document, metadata));\r\n    }\r\n\r\n    transform(document: any, metadata: EntityMetadata) {\r\n        const entity: any = metadata.create();\r\n        let hasData = false;\r\n\r\n        // handle _id property the special way\r\n        if (metadata.objectIdColumn && document[metadata.objectIdColumn.databaseNameWithoutPrefixes]) {\r\n            // todo: we can't use driver in this class\r\n            // do we really need prepare hydrated value here? If no then no problem. If yes then think maybe prepareHydratedValue process should be extracted out of driver class?\r\n            // entity[metadata.objectIdColumn.propertyName] = this.driver.prepareHydratedValue(document[metadata.objectIdColumn.name\"], metadata.objectIdColumn);\r\n            entity[metadata.objectIdColumn.propertyName] = document[metadata.objectIdColumn.databaseNameWithoutPrefixes];\r\n            hasData = true;\r\n        }\r\n\r\n        // add special columns that contains relation ids\r\n        if (this.enableRelationIdValues) {\r\n            metadata.columns.filter(column => !!column.relationMetadata).forEach(column => {\r\n                const valueInObject = document[column.databaseNameWithoutPrefixes];\r\n                if (valueInObject !== undefined && valueInObject !== null && column.propertyName) {\r\n                    // todo: we can't use driver in this class\r\n                    // const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n                    entity[column.propertyName] = valueInObject;\r\n                    hasData = true;\r\n                }\r\n            });\r\n        }\r\n\r\n        /*this.joinMappings\r\n            .filter(joinMapping => joinMapping.parentName === alias.name && !joinMapping.alias.relationOwnerSelection && joinMapping.alias.target)\r\n            .map(joinMapping => {\r\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, joinMapping.alias);\r\n                const isResultArray = joinMapping.isMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result && (!isResultArray || result.length > 0)) {\r\n                    entity[joinMapping.propertyName] = result;\r\n                    hasData = true;\r\n                }\r\n            });*/\r\n\r\n        // get value from columns selections and put them into object\r\n        metadata.ownColumns.forEach(column => {\r\n            const valueInObject = document[column.databaseNameWithoutPrefixes];\r\n            if (valueInObject !== undefined &&\r\n                valueInObject !== null &&\r\n                column.propertyName &&\r\n                !column.isVirtual) {\r\n                // const value = this.driver.prepareHydratedValue(valueInObject, column);\r\n\r\n                entity[column.propertyName] = valueInObject;\r\n                hasData = true;\r\n            }\r\n        });\r\n\r\n        const addEmbeddedValuesRecursively = (entity: any, document: any, embeddeds: EmbeddedMetadata[]) => {\r\n            embeddeds.forEach(embedded => {\r\n                if (!document[embedded.prefix])\r\n                    return;\r\n\r\n                if (embedded.isArray) {\r\n                    entity[embedded.propertyName] = (document[embedded.prefix] as any[]).map(subValue => {\r\n                        const newItem = embedded.create();\r\n                        embedded.columns.forEach(column => {\r\n                            newItem[column.propertyName] = subValue[column.databaseNameWithoutPrefixes];\r\n                        });\r\n                        return newItem;\r\n                    });\r\n\r\n                } else {\r\n                    embedded.columns.forEach(column => {\r\n                        const value = document[embedded.prefix][column.databaseNameWithoutPrefixes];\r\n                        if (!value) return;\r\n\r\n                        if (!entity[embedded.propertyName])\r\n                            entity[embedded.propertyName] = embedded.create();\r\n\r\n                        entity[embedded.propertyName][column.propertyName] = value;\r\n                    });\r\n                }\r\n                addEmbeddedValuesRecursively(entity[embedded.propertyName], document[embedded.prefix], embedded.embeddeds);\r\n            });\r\n        };\r\n\r\n        addEmbeddedValuesRecursively(entity, document, metadata.embeddeds);\r\n\r\n        // if relation is loaded then go into it recursively and transform its values too\r\n        /*metadata.relations.forEach(relation => {\r\n            const relationAlias = this.selectionMap.findSelectionByParent(alias.name, relation.propertyName);\r\n            if (relationAlias) {\r\n                const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"join\" && joinMapping.alias === relationAlias);\r\n                const relatedEntities = this.transformRawResultsGroup(rawSqlResults, relationAlias);\r\n                const isResultArray = relation.isManyToMany || relation.isOneToMany;\r\n                const result = !isResultArray ? relatedEntities[0] : relatedEntities;\r\n\r\n                if (result) {\r\n                    let propertyName = relation.propertyName;\r\n                    if (joinMapping) {\r\n                        propertyName = joinMapping.propertyName;\r\n                    }\r\n\r\n                    if (relation.isLazy) {\r\n                        entity[\"__\" + propertyName + \"__\"] = result;\r\n                    } else {\r\n                        entity[propertyName] = result;\r\n                    }\r\n\r\n                    if (!isResultArray || result.length > 0)\r\n                        hasData = true;\r\n                }\r\n            }\r\n\r\n            // if relation has id field then relation id/ids to that field.\r\n            if (relation.isManyToMany) {\r\n                if (relationAlias) {\r\n                    const ids: any[] = [];\r\n                    const joinMapping = this.joinMappings.find(joinMapping => joinMapping.type === \"relationId\" && joinMapping.alias === relationAlias);\r\n\r\n                    if (relation.idField || joinMapping) {\r\n                        const propertyName = joinMapping ? joinMapping.propertyName : relation.idField as string;\r\n                        const junctionMetadata = relation.junctionEntityMetadata;\r\n                        const columnName = relation.isOwning ? junctionMetadata.columns[1].name : junctionMetadata.columns[0].name;\r\n\r\n                        rawSqlResults.forEach(results => {\r\n                            if (relationAlias) {\r\n                                const resultsKey = relationAlias.name + \"_\" + columnName;\r\n                                const value = this.driver.prepareHydratedValue(results[resultsKey], relation.referencedColumn);\r\n                                if (value !== undefined && value !== null)\r\n                                    ids.push(value);\r\n                            }\r\n                        });\r\n\r\n                        if (ids && ids.length)\r\n                            entity[propertyName] = ids;\r\n                    }\r\n                }\r\n            } else if (relation.idField) {\r\n                const relationName = relation.name;\r\n                entity[relation.idField] = this.driver.prepareHydratedValue(rawSqlResults[0][alias.name + \"_\" + relationName], relation.referencedColumn);\r\n            }\r\n\r\n            // if relation counter\r\n            this.relationCountMetas.forEach(joinMeta => {\r\n                if (joinMeta.alias === relationAlias) {\r\n                    // console.log(\"relation count was found for relation: \", relation);\r\n                    // joinMeta.entity = entity;\r\n                    joinMeta.entities.push({ entity: entity, metadata: metadata });\r\n                    // console.log(joinMeta);\r\n                    // console.log(\"---------------------\");\r\n                }\r\n            });\r\n        });*/\r\n\r\n        return hasData ? entity : null;\r\n    }\r\n\r\n}"],"sourceRoot":"../.."}