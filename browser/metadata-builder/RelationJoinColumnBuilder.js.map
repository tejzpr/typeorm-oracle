{"version":3,"sources":["../browser/src/metadata-builder/RelationJoinColumnBuilder.ts"],"names":[],"mappings":"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","file":"RelationJoinColumnBuilder.js","sourcesContent":["import {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {UniqueMetadata} from \"../metadata/UniqueMetadata\";\r\nimport {ForeignKeyMetadata} from \"../metadata/ForeignKeyMetadata\";\r\nimport {RelationMetadata} from \"../metadata/RelationMetadata\";\r\nimport {JoinColumnMetadataArgs} from \"../metadata-args/JoinColumnMetadataArgs\";\r\nimport {Connection} from \"../connection/Connection\";\r\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\r\n\r\n/**\r\n * Builds join column for the many-to-one and one-to-one owner relations.\r\n *\r\n * Cases it should cover:\r\n * 1. when join column is set with custom name and without referenced column name\r\n * we need automatically set referenced column name - primary ids by default\r\n * @JoinColumn({ name: \"custom_name\" })\r\n *\r\n * 2. when join column is set with only referenced column name\r\n * we need automatically set join column name - relation name + referenced column name\r\n * @JoinColumn({ referencedColumnName: \"title\" })\r\n *\r\n * 3. when join column is set without both referenced column name and join column name\r\n * we need to automatically set both of them\r\n * @JoinColumn()\r\n *\r\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\r\n * we need to create join column for it with proper referenced column name and join column name\r\n *\r\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\r\n * both options are required\r\n * @JoinColumn([\r\n *      { name: \"category_title\", referencedColumnName: \"type\" },\r\n *      { name: \"category_title\", referencedColumnName: \"name\" },\r\n * ])\r\n *\r\n * Since for many-to-one relations having JoinColumn decorator is not required,\r\n * we need to go thought each many-to-one relation without join column decorator set\r\n * and create join column metadata args for them.\r\n */\r\nexport class RelationJoinColumnBuilder {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private connection: Connection) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\r\n     */\r\n    build(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): {\r\n      foreignKey: ForeignKeyMetadata|undefined,\r\n      uniqueConstraint: UniqueMetadata|undefined,\r\n    } {\r\n        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\r\n        if (!referencedColumns.length)\r\n            return { foreignKey: undefined, uniqueConstraint: undefined }; // this case is possible only for one-to-one non owning side\r\n\r\n        const columns = this.collectColumns(joinColumns, relation, referencedColumns);\r\n        const foreignKey = new ForeignKeyMetadata({\r\n            entityMetadata: relation.entityMetadata,\r\n            referencedEntityMetadata: relation.inverseEntityMetadata,\r\n            namingStrategy: this.connection.namingStrategy,\r\n            columns: columns,\r\n            referencedColumns: referencedColumns,\r\n            onDelete: relation.onDelete,\r\n        });\r\n\r\n        // Oracle does not allow both primary and unique constraints on the same column\r\n        if (this.connection.driver instanceof OracleDriver && columns.every(column => column.isPrimary))\r\n            return { foreignKey, uniqueConstraint: undefined };\r\n\r\n        if (referencedColumns.length > 0 && relation.isOneToOne) {\r\n            const uniqueConstraint = new UniqueMetadata({\r\n                entityMetadata: relation.entityMetadata,\r\n                columns: foreignKey.columns,\r\n                args: {\r\n                    name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tablePath, foreignKey.columns.map(c => c.databaseName)),\r\n                    target: relation.entityMetadata.target,\r\n                }\r\n            });\r\n            uniqueConstraint.build(this.connection.namingStrategy);\r\n            return {foreignKey, uniqueConstraint};\r\n        }\r\n\r\n        return { foreignKey, uniqueConstraint: undefined };\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Collects referenced columns from the given join column args.\r\n     */\r\n    protected collectReferencedColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata): ColumnMetadata[] {\r\n        const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\r\n        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\r\n        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\r\n\r\n        if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) { // covers case3 and case1\r\n            return relation.inverseEntityMetadata.primaryColumns;\r\n\r\n        } else { // cases with referenced columns defined\r\n            return joinColumns.map(joinColumn => {\r\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\r\n                if (!referencedColumn)\r\n                    throw new Error(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\r\n\r\n                return referencedColumn;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collects columns from the given join column args.\r\n     */\r\n    private collectColumns(joinColumns: JoinColumnMetadataArgs[], relation: RelationMetadata, referencedColumns: ColumnMetadata[]): ColumnMetadata[] {\r\n        return referencedColumns.map(referencedColumn => {\r\n\r\n            // in the case if relation has join column with only name set we need this check\r\n            const joinColumnMetadataArg = joinColumns.find(joinColumn => {\r\n                return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) &&\r\n                    !!joinColumn.name;\r\n            });\r\n            const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\r\n\r\n            let relationalColumn = relation.entityMetadata.ownColumns.find(column => column.databaseName === joinColumnName);\r\n            if (!relationalColumn) {\r\n                relationalColumn = new ColumnMetadata({\r\n                    connection: this.connection,\r\n                    entityMetadata: relation.entityMetadata,\r\n                    args: {\r\n                        target: \"\",\r\n                        mode: \"virtual\",\r\n                        propertyName: relation.propertyName,\r\n                        options: {\r\n                            name: joinColumnName,\r\n                            type: referencedColumn.type,\r\n                            length: referencedColumn.length,\r\n                            width: referencedColumn.width,\r\n                            charset: referencedColumn.charset,\r\n                            collation: referencedColumn.collation,\r\n                            precision: referencedColumn.precision,\r\n                            scale: referencedColumn.scale,\r\n                            zerofill: referencedColumn.zerofill,\r\n                            unsigned: referencedColumn.unsigned,\r\n                            comment: referencedColumn.comment,\r\n                            primary: relation.isPrimary,\r\n                            nullable: relation.isNullable\r\n                        }\r\n                    }\r\n                });\r\n                relation.entityMetadata.registerColumn(relationalColumn);\r\n            }\r\n            relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\r\n            relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\r\n            relationalColumn.relationMetadata = relation;\r\n            relationalColumn.build(this.connection);\r\n            return relationalColumn;\r\n        });\r\n    }\r\n}\r\n"],"sourceRoot":".."}