{"version":3,"sources":["../browser/src/subscriber/Broadcaster.ts"],"names":[],"mappings":"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","file":"Broadcaster.js","sourcesContent":["import {EntitySubscriberInterface} from \"./EntitySubscriberInterface\";\r\nimport {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {EntityMetadata} from \"../metadata/EntityMetadata\";\r\nimport {BroadcasterResult} from \"./BroadcasterResult\";\r\n\r\n/**\r\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\r\n */\r\nexport class Broadcaster {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(private queryRunner: QueryRunner) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_INSERT\" event.\r\n     * Before insert event is executed before entity is being inserted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral): void {\r\n\r\n        if (entity && metadata.beforeInsertListeners.length) {\r\n            metadata.beforeInsertListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\r\n                    const executionResult = subscriber.beforeInsert({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_UPDATE\" event.\r\n     * Before update event is executed before entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void { // todo: send relations too?\r\n        if (entity && metadata.beforeUpdateListeners.length) {\r\n            metadata.beforeUpdateListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\r\n                    const executionResult = subscriber.beforeUpdate({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        databaseEntity: databaseEntity,\r\n                        updatedColumns: [], // todo: subject.diffColumns,\r\n                        updatedRelations: [] // subject.diffRelations,\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"BEFORE_REMOVE\" event.\r\n     * Before remove event is executed before entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastBeforeRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\r\n        if (entity && metadata.beforeRemoveListeners.length) {\r\n            metadata.beforeRemoveListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\r\n                    const executionResult = subscriber.beforeRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_INSERT\" event.\r\n     * After insert event is executed after entity is being persisted to the database for the first time.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterInsertEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral): void {\r\n\r\n        if (entity && metadata.afterInsertListeners.length) {\r\n            metadata.afterInsertListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\r\n                    const executionResult = subscriber.afterInsert({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_UPDATE\" event.\r\n     * After update event is executed after entity is being updated in the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterUpdateEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\r\n\r\n        if (entity && metadata.afterUpdateListeners.length) {\r\n            metadata.afterUpdateListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\r\n                    const executionResult = subscriber.afterUpdate({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        databaseEntity: databaseEntity,\r\n                        updatedColumns: [], // todo: subject.diffColumns,\r\n                        updatedRelations: [] // todo: subject.diffRelations,\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_REMOVE\" event.\r\n     * After remove event is executed after entity is being removed from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastAfterRemoveEvent(result: BroadcasterResult, metadata: EntityMetadata, entity?: ObjectLiteral, databaseEntity?: ObjectLiteral): void {\r\n\r\n        if (entity && metadata.afterRemoveListeners.length) {\r\n            metadata.afterRemoveListeners.forEach(listener => {\r\n                if (listener.isAllowed(entity)) {\r\n                    const executionResult = listener.execute(entity);\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n\r\n        if (this.queryRunner.connection.subscribers.length) {\r\n            this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\r\n                    const executionResult = subscriber.afterRemove({\r\n                        connection: this.queryRunner.connection,\r\n                        queryRunner: this.queryRunner,\r\n                        manager: this.queryRunner.manager,\r\n                        entity: entity,\r\n                        databaseEntity: databaseEntity,\r\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity)\r\n                    });\r\n                    if (executionResult instanceof Promise)\r\n                        result.promises.push(executionResult);\r\n                    result.count++;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\r\n     * After load event is executed after entity has been loaded from the database.\r\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\r\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\r\n     *\r\n     * Note: this method has a performance-optimized code organization, do not change code structure.\r\n     */\r\n    broadcastLoadEventsForAll(result: BroadcasterResult, metadata: EntityMetadata, entities: ObjectLiteral[]): void {\r\n        entities.forEach(entity => {\r\n            if (entity instanceof Promise) // todo: check why need this?\r\n                return;\r\n\r\n            // collect load events for all children entities that were loaded with the main entity\r\n            if (metadata.relations.length) {\r\n                metadata.relations.forEach(relation => {\r\n\r\n                    // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\r\n                    if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName))\r\n                        return;\r\n\r\n                    const value = relation.getEntityValue(entity);\r\n                    if (value instanceof Object)\r\n                        this.broadcastLoadEventsForAll(result, relation.inverseEntityMetadata, value instanceof Array ? value : [value]);\r\n                });\r\n            }\r\n\r\n            if (metadata.afterLoadListeners.length) {\r\n                metadata.afterLoadListeners.forEach(listener => {\r\n                    if (listener.isAllowed(entity)) {\r\n                        const executionResult = listener.execute(entity);\r\n                        if (executionResult instanceof Promise)\r\n                            result.promises.push(executionResult);\r\n                        result.count++;\r\n                    }\r\n                });\r\n            }\r\n\r\n            if (this.queryRunner.connection.subscribers.length) {\r\n                this.queryRunner.connection.subscribers.forEach(subscriber => {\r\n                    if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad) {\r\n                        const executionResult = subscriber.afterLoad!(entity);\r\n                        if (executionResult instanceof Promise)\r\n                            result.promises.push(executionResult);\r\n                        result.count++;\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Protected Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\r\n     * or listens our entity.\r\n     */\r\n    protected isAllowedSubscriber(subscriber: EntitySubscriberInterface<any>, target: Function|string): boolean {\r\n        return  !subscriber.listenTo ||\r\n            !subscriber.listenTo() ||\r\n            subscriber.listenTo() === Object ||\r\n            subscriber.listenTo() === target ||\r\n            subscriber.listenTo().isPrototypeOf(target);\r\n    }\r\n\r\n}"],"sourceRoot":".."}