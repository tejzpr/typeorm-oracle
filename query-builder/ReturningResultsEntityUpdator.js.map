{"version":3,"sources":["../../src/query-builder/ReturningResultsEntityUpdator.ts"],"names":[],"mappings":"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","file":"ReturningResultsEntityUpdator.js","sourcesContent":["import {ObjectLiteral} from \"../common/ObjectLiteral\";\r\nimport {QueryRunner} from \"../query-runner/QueryRunner\";\r\nimport {OrmUtils} from \"../util/OrmUtils\";\r\nimport {QueryExpressionMap} from \"./QueryExpressionMap\";\r\nimport {ColumnMetadata} from \"../metadata/ColumnMetadata\";\r\nimport {UpdateResult} from \"./result/UpdateResult\";\r\nimport {InsertResult} from \"./result/InsertResult\";\r\nimport {OracleDriver} from \"../driver/oracle/OracleDriver\";\r\n\r\n/**\r\n * Updates entity with returning results in the entity insert and update operations.\r\n */\r\nexport class ReturningResultsEntityUpdator {\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Constructor\r\n    // -------------------------------------------------------------------------\r\n\r\n    constructor(protected queryRunner: QueryRunner,\r\n                protected expressionMap: QueryExpressionMap) {\r\n    }\r\n\r\n    // -------------------------------------------------------------------------\r\n    // Public Methods\r\n    // -------------------------------------------------------------------------\r\n\r\n    /**\r\n     * Updates entities with a special columns after updation query execution.\r\n     */\r\n    async update(updateResult: UpdateResult, entities: ObjectLiteral[]): Promise<void> {\r\n        const metadata = this.expressionMap.mainAlias!.metadata;\r\n\r\n        await Promise.all(entities.map(async (entity, entityIndex) => {\r\n\r\n            // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\r\n            if (this.queryRunner.connection.driver.isReturningSqlSupported()) {\r\n                if (this.queryRunner.connection.driver instanceof OracleDriver && updateResult.raw instanceof Array && this.expressionMap.extraReturningColumns.length > 0) {\r\n                    updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\r\n                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\r\n                        return newRaw;\r\n                    }, {} as ObjectLiteral);\r\n                }\r\n                const result = updateResult.raw instanceof Array ? updateResult.raw[entityIndex] : updateResult.raw;\r\n                const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\r\n                if (returningColumns) {\r\n                    this.queryRunner.manager.merge(metadata.target, entity, returningColumns);\r\n                    updateResult.generatedMaps.push(returningColumns);\r\n                }\r\n\r\n            } else {\r\n\r\n                // for driver which do not support returning/output statement we need to perform separate query and load what we need\r\n                const updationColumns = this.getUpdationReturningColumns();\r\n                if (updationColumns.length > 0) {\r\n\r\n                    // get entity id by which we will get needed data\r\n                    const entityId = this.expressionMap.mainAlias!.metadata.getEntityIdMap(entity);\r\n                    if (!entityId)\r\n                        throw new Error(`Cannot update entity because entity id is not set in the entity.`);\r\n\r\n                    // execute query to get needed data\r\n                    const loadedReturningColumns = await this.queryRunner.manager\r\n                        .createQueryBuilder()\r\n                        .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\r\n                        .addSelect(this.getUpdationReturningColumns().map(column => metadata.targetName + \".\" + column.propertyPath))\r\n                        .from(metadata.target, metadata.targetName)\r\n                        .where(entityId)\r\n                        .getOne();\r\n\r\n                    if (loadedReturningColumns) {\r\n                        this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);\r\n                        updateResult.generatedMaps.push(loadedReturningColumns);\r\n                    }\r\n                }\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Updates entities with a special columns after insertion query execution.\r\n     */\r\n    async insert(insertResult: InsertResult, entities: ObjectLiteral[]): Promise<void> {\r\n        const metadata = this.expressionMap.mainAlias!.metadata;\r\n        const insertionColumns = this.getInsertionReturningColumns();\r\n\r\n        const generatedMaps = entities.map((entity, entityIndex) => {\r\n            if (this.queryRunner.connection.driver instanceof OracleDriver && insertResult.raw instanceof Array && this.expressionMap.extraReturningColumns.length > 0) {\r\n                insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\r\n                    newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\r\n                    return newRaw;\r\n                }, {} as ObjectLiteral);\r\n            }\r\n            // get all values generated by a database for us\r\n            const result = insertResult.raw instanceof Array ? insertResult.raw[entityIndex] : insertResult.raw;\r\n            const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result) || {};\r\n\r\n            // if database does not support uuid generation we need to get uuid values\r\n            // generated by orm and set them to the generatedMap\r\n            if (this.queryRunner.connection.driver.isUUIDGenerationSupported() === false) {\r\n                metadata.generatedColumns.forEach(generatedColumn => {\r\n                    if (generatedColumn.generationStrategy === \"uuid\") {\r\n                        // uuid can be defined by user in a model, that's why first we get it\r\n                        let uuid = generatedColumn.getEntityValue(entity);\r\n                        if (!uuid) // if it was not defined by a user then InsertQueryBuilder generates it by its own, get this generated uuid value\r\n                            uuid = this.expressionMap.nativeParameters[\"uuid_\" + generatedColumn.databaseName + entityIndex];\r\n\r\n                        OrmUtils.mergeDeep(generatedMap, generatedColumn.createValueMap(uuid));\r\n                    }\r\n                });\r\n            }\r\n\r\n            this.queryRunner.manager.merge(metadata.target, entity, generatedMap); // todo: this should not be here, but problem with below line\r\n            return generatedMap;\r\n        });\r\n\r\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\r\n        // for other drivers we have to re-select this data from the database\r\n        if (this.queryRunner.connection.driver.isReturningSqlSupported() === false && insertionColumns.length > 0) {\r\n            await Promise.all(entities.map(async (entity, entityIndex) => {\r\n                const entityId = metadata.getEntityIdMap(entity)!;\r\n\r\n                // to select just inserted entity we need a criteria to select by.\r\n                // for newly inserted entities in drivers which do not support returning statement\r\n                // row identifier can only be an increment column\r\n                // (since its the only thing that can be generated by those databases)\r\n                // or (and) other primary key which is defined by a user and inserted value has it\r\n\r\n                const returningResult: any = await this.queryRunner.manager\r\n                    .createQueryBuilder()\r\n                    .select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\r\n                    .addSelect(insertionColumns.map(column => metadata.targetName + \".\" + column.propertyPath))\r\n                    .from(metadata.target, metadata.targetName)\r\n                    .where(entityId)\r\n                    .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties maight be overridden by merge process\r\n                    .getOne();\r\n\r\n                this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult);\r\n            }));\r\n        }\r\n\r\n        entities.forEach((entity, entityIndex) => {\r\n            const entityId = metadata.getEntityIdMap(entity)!;\r\n            insertResult.identifiers.push(entityId);\r\n            insertResult.generatedMaps.push(generatedMaps[entityIndex]);\r\n            this.queryRunner.manager.merge(this.expressionMap.mainAlias!.metadata.target, entity, generatedMaps[entityIndex], generatedMaps[entityIndex]); // todo: why twice?!\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Columns we need to be returned from the database when we insert entity.\r\n     */\r\n    getInsertionReturningColumns(): ColumnMetadata[] {\r\n\r\n        // for databases which support returning statement we need to return extra columns like id\r\n        // for other databases we don't need to return id column since its returned by a driver already\r\n        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported();\r\n\r\n        // filter out the columns of which we need database inserted values to update our entity\r\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\r\n            return  column.default !== undefined ||\r\n                    (needToCheckGenerated && column.isGenerated)  ||\r\n                    column.isCreateDate ||\r\n                    column.isUpdateDate ||\r\n                    column.isVersion;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Columns we need to be returned from the database when we update entity.\r\n     */\r\n    getUpdationReturningColumns(): ColumnMetadata[] {\r\n        return this.expressionMap.mainAlias!.metadata.columns.filter(column => {\r\n            return column.isUpdateDate || column.isVersion;\r\n        });\r\n    }\r\n\r\n}"],"sourceRoot":".."}